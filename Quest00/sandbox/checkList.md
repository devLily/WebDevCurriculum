# Checklist

- 형상관리 시스템은 왜 나오게 되었을까요?
- git은 어떤 형상관리 시스템이고 어떤 특징을 가지고 있을까요? 분산형 형상관리 시스템이란 무엇일까요?
  - git은 어떻게 개발되게 되었을까요? git이 분산형 시스템을 채택한 이유는 무엇일까요?
- git과 GitHub은 어떻게 다를까요?
- git의 clone/add/commit/push/pull/branch/stash 명령은 무엇이며 어떨 때 이용하나요? 그리고 어떻게 사용하나요?
- git의 Object, Commit, Head, Branch, Tag는 어떤 개념일까요? git 시스템은 프로젝트의 히스토리를 어떻게 저장할까요?
- 리모트 git 저장소에 원하지 않는 파일이 올라갔을 때 이를 되돌리려면 어떻게 해야 할까요?

## 형상관리 시스템은 왜 나오게 되었을까요?

- 소프트웨어의 형상관리 Software Configuration Management(SCM)
- 개발 과정 및 유지 보수과정에서 발생하는 소스코드, 문서, 인터페이스 등에 대한 형상을 만들어 이에 대한 변경을 체계적으로 관리, 제어하기 위함
- 동일한 기능을 동시에 여러 개발자가 개발하는 과정에서 작성된 소스코드와 변경사항, 수정, 삭제, 충돌 해결 등의 협업을 도와주기 위해 버전관리 시스템이 필요하다

1. 개발 과정에서의 코드 변경 사항 보존
2. 버그 및 이슈 발생시 추적 용이
3. 특정 시점의 코드 및 디렉토리 확인 및 롤백
4. 협업과정에서 하나의 소스를 가지고 효율적으로 작업할 수 있게 하기 위함

- 상용
  IBM Rational ClearCase, Perforce, PTC Integrity
- 비상용(오픈소스)
  Subversion(SVN), CVS, Git

- 버전 관리 시스템은 파일 변화를 시간에 따라 기록했다가 나중에 특정 시점의 버전을 다시 꺼내올 수 있는 시스템이다. 각 파일을 이전 상태로 되돌릴 수 있고, 프로젝트를 통째로 이전 상태로 되돌릴 수 있고, 시간에 따라 수정 내용을 비교해 볼 수 있고, 누가 문제를 일으켰는지도 추적할 수 있고, 누가 언제 만들어낸 이슈인지도 알 수 있다. VCS를 사용하면 파일을 잃어버리거나 잘못 고쳤을 때도 쉽게 복구할 수 있다.

- DVCS(분산 버전 관리 시스템), Git, Mecurial, Bazaar, Darcs 같은 DVCS에서의 클라이언트는 단순히 파일의 마지막 스냅샷을 Checkout 하지 않는다. 그냥 저장소를 히스토리와 더불어 전부 복제한다. 서버에 문제가 생기면 이 복제물로 다시 작업을 시작할 수 있다. 클라이언트 중에서 아무거나 골라도 서버를 복원할 수 있다. Clone은 모든 데이터를 가진 진정한 백업이다.

## git은 어떤 형상관리 시스템이고 어떤 특징을 가지고 있을까요? 분산형 형상관리 시스템이란 무엇일까요?

- 분산 버전 관리 시스템

## git은 어떻게 개발되게 되었을까요? git이 분산형 시스템을 채택한 이유는 무엇일까요?

## git과 GitHub은 어떻게 다를까요?

## git의 clone/add/commit/push/pull/branch/stash 명령은 무엇이며 어떨 때 이용하나요? 그리고 어떻게 사용하나요?

### commit

커밋은 Git 저장소에 디렉토리에 있는 모든 파일에 대한 스냅샷을 기록하는 것. 디렉토리 전체를 복사하여 붙여넣는것과 유사하지만, 훨씬 유용한 방법이다! Git은 가능한 한 커밋을 가볍게 유지하고자 하기때문에, 커밋할 때마다 디렉토리 전체를 복사하지는 않는다. 각 커밋은 저장소의 이전 버전과 다음 버전의 변경내역("delta"라고도 함)을 저장한다. 그래서 대부분의 커밋이 그 커밋 위의 부모 커밋을 가리킨다. 저장소를 복제(clone)하려면 모든 변경분(delta)를 풀어내야 하는데, 이 때문에 명령행 결과로 아래 문구를 볼 수 있다.

resolving deltas

일단 커밋을 프로젝트의 스냅샷들로 생각하면 충분하다. 커밋은 매우 가볍고 커밋 사이의 전환도 매우 빠르다는 것을 기억!

### branch

깃의 브랜치도 놀랍도록 가볍다. 브랜치는 특정 커밋에 대한 참조(reference)에 지나지 않는다. 이런 사실 때문에 수많은 Git 애찬론자들은 아래와 같이 주장한다.

브랜치를 서둘러서, 그리고 자주 만드세요
브랜치를 많이 만들어도 메모리나 디스크 공간에 부담이 되지 않기 때문에, 여러분의 작업을 커다른 브랜치로 만들기 보다, 작은 단위로 잘게 나누는 것이 좋습니다.

브랜치와 커밋을 같이 쓸 때, 어떻게 두 기능이 조화를 이루는지 알아야한다. 하지만 우선은, 단순히 브랜치를 "하나의 커밋과 그 부모 커밋들을 포함하는 작업 내역"이라고 기억하면 된다.

- checkout :
- cherry-pick:
- reset :
- revert :

### rebase

브랜치끼리의 작업을 접목하는 두번째 방법은 리베이스(rebase). 리베이스는 기본적으로 커밋들을 모아서 복사한 뒤, 다른 곳에 떨궈 놓는 것.
리베이스를 하면 커밋들의 흐름을 보기 좋게 한 줄로 만들 수 있다는 장점이 있다. 리베이스를 쓰면 저장소의 커밋 로그와 이력이 한결 깨끗해진다.

### merge

Git의 합치기(merge)는 두 개의 부모(parent)를 가리키는 특별한 커밋을 만든다. 두개의 부모가 있는 커밋이라는 것은 "한 부모의 모든 작업내역과 나머지 부모의 모든 작업, 그리고 그 두 부모의 모든 부모들의 작업내역을 포함한다"라는 의미가 있다.

## git의 clone/add/commit/push/pull/branch/stash 명령은 무엇이며 어떨 때 이용하나요? 그리고 어떻게 사용하나요?

## git의 Object, Commit, Head, Branch, Tag는 어떤 개념일까요? git 시스템은 프로젝트의 히스토리를 어떻게 저장할까요?

프로젝트를 표현하는 커밋 트리(commit tree)에서 이동 할 수 있는 여러가지 방법들을 아는것이 중요하다.

### HEAD

HEAD는 현재 체크아웃된 커밋을 가리킨다. -- 다시 말하자면 현재 작업중인 커밋

HEAD는 항상 작업트리의 가장 최근 커밋을 가리키고 작업트리에 변화를 주는 git 명령어들은 대부분 HEAD를 변경하는것으로 시작한다.
일반적으로 HEAD는 브랜치의 이름을 가리키고 있다(bugFix와 같이). 커밋을 하게 되면, bugFix의 상태가 바뀌고 이 변경은 HEAD를 통해서 확인 가능
HEAD를 분리한다는 것은 HEAD를 브랜치 대신 커밋에 붙이는 것을 의미.
각 커밋은 그것의 해시값으로 특정지을수 있다. 각 커밋의 해시값은 각 커밋을 나타내는 원안에 나타나있다.

### 상대참조 : Relative Ref / fed2

Git에서 여기저기 이동할 때 커밋의 해시를 사용하는 방법은 조금 귀찮다. 실제로 Git을 사용할 때는 터미널화면 옆에 커밋트리가 보이지 않으므로 매번 해시를 확인하려고 git log 명령어를 쳐야하는 불편함이 있다.
나아가서, 실제 Git에서는 해시들이 훨씬 더 긴데 예를 들어 이전 레벨에 소개했던 커밋의 해시는 fed2da64c0efc5293610bdd892f82a58e8cbc5d8
그렇지만 해시가 커밋의 고유한 값임을 보여줄 수 있을 만큼만 명시해주면 된다. 위의 긴 문자열 대신 fed2만 입력 가능.
커밋들을 해시로 구분하고 사용하는것이 아주 편하다고 볼 수는 없으나 Git의 상대 참조(Relative Ref)가 여기서 등장.

상대 참조로 우리가 기억할 만한 지점(브랜치 bugFix라던가 HEAD라던가)에서 출발해서 이동하여 다른 지점에 도달해 작업을 할 수 있다.
상대 커밋은 강력한 기능인데, 여기서 두가지 간단한 방법이 존재.

한번에 한 커밋 위로 움직이는 ^
한번에 여러 커밋 위로 올라가는 ~<num>

Git 데모

### 캐럿 (^) 연산자

참조 이름에 하나씩 추가할 때마다, 명시한 커밋의 부모를 찾게 된다.

main^는 "main의 부모"와 같은 의미.

main^^ 는 "main의 조부모(부모의 부모)"를 의미

### "~"틸드 연산자

커밋트리에서 위로 여러 단계를 올라가고 싶을 수 있다. ^를 계속 입력해서 올라가는것 말고 Git 에는 틸드 (~) 연산자가 있다.
(~) 틸드 연산자는 (선택적) 올라가고 싶은 부모의 갯수가 뒤에 숫자를 입력한다.
돌아가고 싶은 커밋의 갯수를 ~뒤의 숫자로 명시.

```
git checkout Head~4
```

- 브랜치 강제로 옮기기
  상대 참조를 사용하는 가장 일반적인 방법은 브랜치를 옮길 때.
  -f 옵션을 이용해서 브랜치를 특정 커밋에 직접적으로 재지정 할 수 있다.

```
git branch -f main HEAD~3
```

## 리모트 git 저장소에 원하지 않는 파일이 올라갔을 때 이를 되돌리려면 어떻게 해야 할까요?
